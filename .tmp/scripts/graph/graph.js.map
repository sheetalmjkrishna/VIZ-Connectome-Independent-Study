{"version":3,"sources":["graph/graph.js"],"names":["Graph","data","self","nodes","edges","nodeIdToIndexes","nodeLabelToIndexes","nodeOutEdgeIndexes","nodeInEdgeIndexes","verbose","maxNumPaths","createNodes","createEdges","nodeData","i","length","nodeIndex","node","Node","id","push","indexList","label","edgeData","edgeIndex","edge","Edge","sourceId","targetId","sourceIndex","targetIndex","directional","paths","nodeConstraints","edgeConstraints","console","log","maxNumHops","finishedPaths","counter","currentPath","shift","currentNode","getLastNode","currentHop","getNumEdges","graph","filter","d","slice","nextNodeConstraint","nextEdgeConstraint","currentNodeIndex","currentNodeOutEdges","currentEdge","type","match","includes","nextNodeId","nextNodeIndex","nextNode","newPath","Path","addNode","addEdge","path","fillInPathsByRegex"],"mappings":"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","file":"graph.js","sourcesContent":["class Graph {\r\n\r\n  /**\r\n   * Create the graph\r\n   * data - marclab formatted json object.\r\n   */\r\n  constructor(data) {\r\n    let self = this;\r\n    self.data = data;\r\n    self.nodes = [];\r\n    self.edges = [];\r\n\r\n    self.nodeIdToIndexes = {}; // key: node id, value: node index\r\n    self.nodeLabelToIndexes = {}; // key: node label, value: node indexes\r\n\r\n    self.nodeOutEdgeIndexes = []; // key: nodeIndex, value: list of edge indexes\r\n    self.nodeInEdgeIndexes = [];\r\n\r\n    // set to true/false to enable debug printing.\r\n    self.verbose = false;\r\n    self.maxNumPaths = 100000;\r\n\r\n    self.createNodes(data.nodes);\r\n    self.createEdges(data.edges);\r\n  }\r\n\r\n  /**\r\n   * Create list of nodes stored in linear array.\r\n   * - nodeData - marclab formatted list of nodes\r\n   */\r\n  createNodes(nodeData) {\r\n    let self = this;\r\n    for (let i = 0; i < nodeData.length; ++i) {\r\n      let nodeIndex = self.nodes.length;\r\n      let node = new Node(nodeData[i]);\r\n\r\n      self.nodeIdToIndexes[node.id] = nodeIndex;\r\n      self.nodes.push(node);\r\n      self.nodeOutEdgeIndexes.push([]);\r\n      self.nodeInEdgeIndexes.push([]);\r\n\r\n      // Keep a map from label to indexes.\r\n      let indexList = self.nodeLabelToIndexes[node.label];\r\n      if (!indexList) {\r\n        self.nodeLabelToIndexes[node.label] = [nodeIndex];\r\n      } else {\r\n        self.nodeLabelToIndexes[node.label].push(nodeIndex);\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create list of edges stored in linear array.\r\n   * If edges are bidirectional, create an edge with -id.\r\n   * - edgeData - marclab formatted list of edges\r\n   */\r\n  createEdges(edgeData) {\r\n    let self = this;\r\n\r\n    for (let i = 0; i < edgeData.length; ++i) {\r\n      let edgeIndex = self.edges.length;\r\n      let edge = new Edge(edgeData[i]);\r\n\r\n      self.edges.push(edge);\r\n\r\n      let sourceId = edge.sourceId;\r\n      let targetId = edge.targetId;\r\n\r\n      let sourceIndex = self.nodeIdToIndexes[sourceId];\r\n      let targetIndex = self.nodeIdToIndexes[targetId];\r\n\r\n      self.nodeOutEdgeIndexes[sourceIndex].push(edgeIndex);\r\n      self.nodeInEdgeIndexes[targetIndex].push(edgeIndex);\r\n\r\n      if (!edge.directional) {\r\n        edge = new Edge(edgeData[i]); // create new to avoid reference.\r\n        edge.id = -edge.id;\r\n        edge.targetId = sourceId;\r\n        edge.sourceId = targetId;\r\n\r\n        edgeIndex = self.edges.length;\r\n        self.edges.push(edge);\r\n        self.nodeOutEdgeIndexes[targetIndex].push(edgeIndex);\r\n        self.nodeInEdgeIndexes[sourceIndex].push(edgeIndex);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Walk on 'paths' following allowed edge and node constraints.\r\n   * Return a list of paths that match the constraints.\r\n   */\r\n  fillInPathsByRegex(paths, nodeConstraints, edgeConstraints) {\r\n    let self = this;\r\n    if (self.verbose) {\r\n      console.log('fillInPathsByRegex', paths, nodeConstraints, edgeConstraints);\r\n    }\r\n\r\n    let maxNumHops = edgeConstraints.length;\r\n    let finishedPaths = [];\r\n    let counter = self.maxNumPaths;\r\n\r\n    while (paths.length && counter > 0) {\r\n      let currentPath = paths.shift();\r\n      let currentNode = currentPath.getLastNode();\r\n      let currentHop = currentPath.getNumEdges();\r\n\r\n      // Have we already finished this path?\r\n      if (currentHop >= maxNumHops) {\r\n        if (self.verbose) {\r\n          console.log('finished path', currentPath);\r\n        }\r\n        if(currentPath.edges.length==currentPath.nodes.length){\r\n          currentPath.nodes.push(currentPath.graph.nodes.filter(function (d) {\r\n            return d.id==currentPath.edges.slice(-1)[0].targetId ;\r\n        })[0]);\r\n        }\r\n        finishedPaths.push(currentPath);\r\n        continue;\r\n      }\r\n\r\n      if (self.verbose) {\r\n        console.log('walking on path', currentPath, currentNode, currentHop);\r\n      }\r\n\r\n      let nextNodeConstraint = nodeConstraints[currentHop + 1];\r\n      let nextEdgeConstraint = edgeConstraints[currentHop];\r\n\r\n      let currentNodeIndex = self.nodeIdToIndexes[currentNode.id];\r\n      let currentNodeOutEdges = self.nodeOutEdgeIndexes[currentNodeIndex];\r\n\r\n      // Try all of the outgoing edges...\r\n      for (let i = 0; i < currentNodeOutEdges.length; ++i) {\r\n        let edgeIndex = currentNodeOutEdges[i];\r\n        let currentEdge = self.edges[edgeIndex];\r\n\r\n        if (self.verbose) {\r\n          console.log('trying to walk on edge', currentEdge);\r\n        }\r\n\r\n        // Are we allowed to walk on the current edge?\r\n        //either the constraint is a regex and the regex should match or it's an array of ids and the array should contain this id\r\n        if ((nextEdgeConstraint.length==null && currentEdge.type.match(nextEdgeConstraint)) || (nextEdgeConstraint.length!=null && nextEdgeConstraint.includes(currentEdge.id))) {\r\n          let nextNodeId = currentEdge.targetId;\r\n          let nextNodeIndex = self.nodeIdToIndexes[nextNodeId];\r\n          let nextNode = self.nodes[nextNodeIndex];\r\n\r\n          if (self.verbose) {\r\n            console.log('walked on edge, found node', nextNode);\r\n          }\r\n          if ((nextNodeConstraint.length==null && nextNode.label.match(nextNodeConstraint)) || (nextNodeConstraint.length!=null && nextNodeConstraint.includes(nextNode.id))) {\r\n          //if (nextNode.label.match(nextNodeConstraint)) {\r\n            let newPath = new Path(this, currentPath.nodes, currentPath.edges);\r\n            newPath.addNode(nextNode); // nodes must be added BEFORE edges.\r\n            newPath.addEdge(currentEdge);\r\n            paths.push(newPath);\r\n            if (self.verbose) {\r\n              console.log('found next node, creating new path', nextNode);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      counter--;\r\n    }\r\n    return finishedPaths;\r\n  }\r\n\r\n  /**\r\n   * Find paths from nodes.\r\n   * - nodeConstraints - list of label regular expressions.\r\n   * - edgeConstraints - list of edge type regular expressions.\r\n   */\r\n  findPathsByRegex(nodeConstraints, edgeConstraints) {\r\n    let self = this;\r\n    let paths = [];\r\n    for (let i = 0; i < self.nodes.length; ++i) {\r\n      let node = self.nodes[i];\r\n      if ((nodeConstraints[0].length==null && node.label.match(nodeConstraints[0])) || (nodeConstraints[0].length!=null && nodeConstraints[0].includes(node.id))) {\r\n     // if (node.label.match(nodeConstraints[0])) {\r\n        let path = new Path(this);\r\n        path.addNode(node);\r\n        paths.push(path);\r\n        if (self.verbose) {\r\n          console.log('created seed path', path)\r\n        }\r\n      }\r\n    }\r\n\r\n    return self.fillInPathsByRegex(paths, nodeConstraints, edgeConstraints);\r\n  }\r\n}\r\n"]}