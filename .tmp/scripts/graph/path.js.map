{"version":3,"sources":["graph/path.js"],"names":["Path","graph","nodes","edges","self","concat","node","edge","getLastEdge","targetId","id","push","length"],"mappings":";;;;;;IAAMA,I;;AAEJ;;;AAGA,gBAAYC,KAAZ,EAAmBC,KAAnB,EAA0BC,KAA1B,EAAiC;AAAA;;AAC/B,QAAIC,OAAO,IAAX;AACAA,SAAKH,KAAL,GAAaA,KAAb;AACAG,SAAKF,KAAL,GAAaA,QAAQ,GAAGG,MAAH,CAAUH,KAAV,CAAR,GAA2B,EAAxC;AACAE,SAAKD,KAAL,GAAaA,QAAQ,GAAGE,MAAH,CAAUF,KAAV,CAAR,GAA2B,EAAxC;AACD;;AAED;;;;;;;4BAGQG,I,EAAM;AACZ,UAAIF,OAAO,IAAX;AACA,UAAIG,OAAOH,KAAKI,WAAL,EAAX;AACA,UAAID,QAAQA,KAAKE,QAAL,IAAiBH,KAAKI,EAAlC,EAAsC;AACpC;AACD,OAFD,MAGK;AACHN,aAAKF,KAAL,CAAWS,IAAX,CAAgBL,IAAhB;AACD;AACD;;;AAGD;;AAED;;;;;;4BAGQC,I,EAAM;AACZ,UAAIH,OAAO,IAAX;AACAA,WAAKD,KAAL,CAAWQ,IAAX,CAAgBJ,IAAhB;AACD;;AAED;;;;;;kCAGc;AACZ,UAAIH,OAAO,IAAX;AACA,UAAIA,KAAKD,KAAL,CAAWS,MAAf,EAAuB;AACrB,eAAOR,KAAKD,KAAL,CAAWC,KAAKD,KAAL,CAAWS,MAAX,GAAoB,CAA/B,CAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF;;AAED;;;;;;kCAGc;AACZ,UAAIR,OAAO,IAAX;AACA,UAAIA,KAAKF,KAAL,CAAWU,MAAf,EAAuB;AACrB,eAAOR,KAAKF,KAAL,CAAWE,KAAKF,KAAL,CAAWU,MAAX,GAAoB,CAA/B,CAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF;;AAED;;;;;;kCAGc;AACZ,UAAIR,OAAO,IAAX;AACA,aAAOA,KAAKD,KAAL,CAAWS,MAAlB;AACD","file":"path.js","sourcesContent":["class Path {\r\n\r\n  /**\r\n   * Create a new empty path or deep copy nodes and edges into a new path.\r\n   */\r\n  constructor(graph, nodes, edges) {\r\n    let self = this;\r\n    self.graph = graph;\r\n    self.nodes = nodes ? [].concat(nodes) : [];\r\n    self.edges = edges ? [].concat(edges) : [];\r\n  }\r\n\r\n  /**\r\n   * Add a node with simple error checking.\r\n   */\r\n  addNode(node) {\r\n    let self = this;\r\n    let edge = self.getLastEdge();\r\n    if (edge && edge.targetId != node.id) {\r\n      //throw 'Tried to create a garbage path with edge/node mistmatch';\r\n    } \r\n    else {\r\n      self.nodes.push(node);\r\n    }\r\n    /*if (!(edge && edge.targetId != node.id)) {\r\n      self.nodes.push(node);\r\n    } */\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  addEdge(edge) {\r\n    let self = this;\r\n    self.edges.push(edge);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  getLastEdge() {\r\n    let self = this;\r\n    if (self.edges.length) {\r\n      return self.edges[self.edges.length - 1];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  getLastNode() {\r\n    let self = this;\r\n    if (self.nodes.length) {\r\n      return self.nodes[self.nodes.length - 1];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n  *\r\n  */\r\n  getNumEdges() {\r\n    let self = this;\r\n    return self.edges.length;\r\n  }\r\n}\r\n"]}